
## Sort

**1. 선택 정렬(Selection Sort)**
 - 장점 : 구현이 쉽다. 공간적 효율이 좋다. 버블정렬과 시간복잡도는 같지만, 실제로 측정하면 버블보다는 조금 더 빠른 정렬방식
 - 단점 : 시간복잡도가 O(n^2) → 오래걸림
 - 시간복잡도 : O(n^2)
 
**2. 버블 정렬(Bubble Sort)**
 - 장점 : 구현이 쉽다. 코드가 직관적이다.
 - 단점 : 비효율적이다. 최악이든 최선이든 O(n^2)의 시간복잡도를 가짐
 - 시간복잡도 : O(n^2)

**3. 퀵 정렬(Quick Sort)**
 - 장점 : 시간적 효율이 좋음 → 기준값을 기준으로 분할을 통해서 구현하는 정렬법. 분할 과정에서 logN 이라는 시간이 걸림. 전체적으로 보게 되면 NlogN 으로써 실행시간이 준수한 편이다.
 - 단점 : 기준값에 따라서 시간복잡도가 크게 달라진다. Pivot이 적당한 이상적인 값이면 시간복잡도가 NlogN이지만 최악의 경우 O(N^2)
 - 시간복잡도 : O(NlogN), 최악의 경우 O(n^2)

**4. 힙 정렬(Heap Sort)**
 - 장점 : 추가적인 메모리를 필요로 하지 않으면서 항상 O(NlogN) 이라는 시간복잡도를 가지는 굉장히 정렬법들 중에서 효율적인 정렬법이라고 볼 수 있다.
 - 단점 : 실제 시간을 측정해보면 퀵정렬보다 느림. 데이터의 상태에 따라서 다른 정렬법들에 비해서 조금 느린편이다. 안정성을 보장받지 못함.
 - 시간복잡도 : O(NlogN)

**5. 병합 정렬(Merge Sort)**
 - 장점 : 퀵소트와 비슷하게 배열을 반씩 분할하면서 정렬하는 방법으로 logN만큼의 시간이 걸림 -> 최종적으로 NlogN의 시간이 걸림. 퀵소트와 달리, Pivot을 설정하는 과정이 없이 무조건 절반으로 분할하기 때문에 Pivot에 따라서 성능이 안좋아지는 경우가 없음
 - 단점 : 추가적인 메모리 필요
 - 시간복잡도 : O(NlogN)

**6. 삽입 정렬(Insertion Sort)**
- 장점 : 최선의 경우 O(N)
- 단점 : 최악의 경우 O(N^2) -> 데이터의 상태 및 크기에 따라서 성능의 편차가 심함.
- 시간복잡도 : 최선 O(N), 최악 


## 스택

![stack](https://user-images.githubusercontent.com/45057466/97438280-ee94ff00-1967-11eb-9755-9dbfab889975.png)

  한 쪽 끝에서만 자료를 넣고 뺄 수 있는 선형 구조(LIFO - Last In First Out)
  
  push : 자료를 밀어 넣는다.
  
  pop : 가장 최근에 넣은(가장 위에 있는) 자료를 꺼낸다.
    
    
## 큐

![queue](https://user-images.githubusercontent.com/45057466/97438299-f3f24980-1967-11eb-8ee6-a65bcff7a813.png)

  뒤에서 자료를 넣고 앞에서만 뺼 수 있는 선형 구조(FIFO - First In First Out)
  
  push : 자료를 밀어 넣는다.
  
  pop : 가장 오래된(가장 앞에 있는) 자료를 꺼낸다.

  자바에서 큐는 스택과 달리 별도의 인터페이스 형태로 제공
  
  링크드리스트를 이용해서 큐 메모리 구조를 구현이 가능하다
  
## Heap

  우선 순위 큐를 위해서 만들어진 자료구조
  
  우선순위 큐 : 데이터들이 우선순위를 가지고 있고 우선순위가 높은 데이터가 먼저 나간다.
  

