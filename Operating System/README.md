
# Process(프로세스) & Thread(스레드)

프로그램 : 어떤 작업을 위해 실행할 수 있는 파일

**프로세스 : 실행중인 프로그램**

**스레드 : 프로세스의 실행 단위**

**PCB(Process Control Block)**

: 특정 프로세스에 대한 중요한 정보를 저장하고 있는 커널 내의 자료구조

👉커널 : 운영체제를 켤 때 맨처음에 실행되는 프로세스

- PCB에 저장되는 정보
    - 프로세스 식별자
    - 프로세스 상태
    - 프로그램 카운터
    - CPU 레지스터
    - CPU 스케줄링 정보
    - 메모리 관리 정보
    - 입출력 상태 정보
    - 어카운팅 정보

**프로세스 상태**

   new(생성)\
   Ready(준비)\
   Running(실행)\
   Waiting(대기)\
   Terminated(종료)

**스레드 구조**

   code, data, stack, heap

**Context Switching(문맥 교환)이란?**
 : 여러 프로세스를 처리해야하는 상황에서 현재 진행중인 Task(프로세스, 스레드)의 상태를 PCB에 저장하고 다음에 진행할 Task의 상태값을 읽어서 적용하는 과정

과정

- Task의 대부분 정보는 Register에 저장되고 PCB로 관리된다.
- 현재 실행하고 있는 Task의 PCB 정보를 저장한다.
- 다음 실행할 Task의 PCB 정보를 읽어 Register에 적재하고 CPU가 이전에 진행했던 과정을 연속적으로 수행할 수 있다.

Context Switching은 많은 비용이 소모된다.

- Cache 초기화
- Memory mapping 초기화
- 커널은 항상 실행되어야 한다.
Context Switching의 비용은 프로세스가 스레드보다 더 많이 든다.

이유 : 스레드는 Stack 영역을 제외한 모든 메모리를 공유하기 때문에 Context Switching 발생시 Stack 영역만 변경을 진행하면 되기 때문이다.


**멀티 프로세스(Multi Process)**

 : 하나의 응용프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것.

 - 장점
 	- 여러 개의 자식 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스만 죽는 것 이상으로 다른 영향이 확산되지 않는다. (안전성)
 - 단점
 	- Context Switching에서의 오버헤드 : 프로세스는 각 독립된 메모리 영역을 할당받았기 때문에 공유하는 메모리가 없다. 따라서 캐시 메모리 초기화 등의 무거운 작업이 진행되고 많은 시간이 소모되는 등의 오버헤드가 발생할 문제가 있다.
	- 프로세스 간 통신 기법 IPC : 프로세스는 각 독립된 메모리 영역을 할당받았기 때문에 프로세스들 사이에서 변수나 자료구조를 공유할 수 없다. 따라서 IPC라는 방법을 사용해야 하며, 이는 어렵고 복잡한 통신 방법이다.

**멀티 스레드(Multi Thread)**

 : 하나의 응용 프로그램을 여러 개의 스레드로 구성하고 각 스레드가 하나의 작업을 처리하도록 하는 것.

윈도우, 리눅스 등 많은 OS들이 멀티 프로세싱을 지원하고 있지만, 멀티 스레딩을 기본으로 하고 있다.

웹 서버는 대표적인 멀티 스레드 응용 프로그램이다.

 - 장점
	- 메모리 공간과 시스템 자원 소모가 줄어들게 된다.
	- 스레드 간 통신시, 전역 변수의 공간 또는 동적으로 할당된 공간인 Heap 영역을 이용해 데이터를 주고 받으므로 통신 방법이 간단하다.
	- Context switching 시, 캐시 메모리를 비울 필요가 없기 때문에 비용이 적고 더 빠르다.
	- 따라서 시스템의 처리량이 향상되고 자원 소모가 줄어들며, 자연스럽게 프로그램의 응답 시간이 단축된다.
 - 단점

	- 서로 다른 스레드가 Data, Heap 영역 등을 공유하기 때문에 어떤 스레드가 다른 스레드에서 사용중인 변수나 자료구조에 접근하여 엉뚱한 값을 읽어오거나 수정할 수 있다. 즉, 자원 공유의 문제가 발생한다.(동기화)
	- 하나의 스레드에 문제가 생기면 전체 프로세스가 영향을 받는다.
	- 주의 깊은 설계가 필요하며, 디버깅이 까다롭다

 **멀티스레드 Vs 멀티프로세스**
 
- 멀티 스레드는 적은 메모리 공간을 차지하고 Context Switching이 빠르다는 장점이 있지만, 오류로 인해 하나의 스레드가 종료되면 전체 스레드가 종료될 수 있다는 점과 동기화 문제를 가지고 있다.

- 멀티 프로세싱은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만, 많은 메모리 공간과 CPU 시간을 차지한다는 단점이 존재한다.

이 두 가지는 동시에 여러 작업을 수행한다는 점에서 같지만 적용해야 하는 시스템에 따라 적합/부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택하고 적용해야 한다.


# 동기화

**프로세스 동기화(매우 중요 ⭐⭐⭐)**

공부할 것

- 경쟁 상태(race condition), 임계 구역(critical section) 문제에 대한 명확한 이해
- 임계 구역 해결 조건: 1. 상호 배제, 2. 진행, 3. 제한 대기
- 임계 구역 해결 방법
    - 피터슨 알고리즘 (데커, 램포트 빵집)
    - 하드웨어 솔루션: test_and_set, compare_and_swap
    - 뮤텍스, 세마포어 (in RTOS), 모니터 (in Java)

동기화(synchronization) : 한정적인 시스템 자원에 여러 스레드가 동시에 접근해서 사용하면 문제가 발생할 수 있기 때문에 이를 방지하기 위해서 여러 스레드에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정하는 기법.

race condition(경쟁 상태) : 두 개이상의 스레드가 공유된 자원에 접근하려고 할 때, 동기화 메커니즘이 없이 접근하려는 상황

	ex) counter++를 실행할때, 어셈블리어는 3단계를 거쳐야함

	register1 = counter
	register1 = register1 + 1
	counter = register

	만약 counter++, counter--를 동시에 실행한다고 했을때, counter의 초기값이 5라면 결과값이 5가 되어야함.

	but,
	register1 = counter		//register1 = 5
	register2 = counter		//register2 = 5
	register 1 = register1 + 1	//register1 = 6
	register 2 = register2 - 1	//register2 = 4
	counter = register1		//counter = 6
	counter = register2		//counter = 4

	위와 같이 잘못된 결과가 나올 수 있음. 이를 해결하기 위해서 동기화가 필요로 함.

critical section(임계 영역) : 공유되는 자원에서 문제가 발생하지 않도록 독점을 보장해주는 영역

concurrent : multiprogram 하나의 CPU로 여러개의 프로그램을 돌린다.

parallel : multiprocess 여러개의 CPU로 하나의 프로그램을 돌린다.

**Critical Section(임계 영역) 해결 조건 3가지**

1.  Mutual exclusion(상호 배제) : 한 프로세스가 공유자원을 접근하는 critical section을 수행중일때는 다른 프로세스가 공유자원에 접근할 수 없다.
2. Progress(진행) :  critical section에 실행중인 process가 없을때 별도의 동작이 없는 프로세스 들만 critical section에 집입할 수 있다.
3. Bounded Waiting(한정된 대기) : 진입 신청 후 부터 진입까지의 waiting이 제한적이어야한다.

=> critical section문제를 해결하기 위한 프로그래밍 기법이 synchronization
=> race condition은 critical section현상을 설명하는 이론

**세마포어**

: 공유된 자원의 데이터를 여러 프로세스, 스레드가 접근하는 것을 막음.

특징 : 동시에 접근할 수 있는 허용 가능한 갯수를 가지고 있는 Counter가 있음

   ex) 공용화장실에 칸이 4개일때 4칸이 비어있으면 기다릴 필요가 없음. 칸이 모두 차있으면 대기

문제점 : 소유가 불가능 -> 세마포어를 소유하지 않은 스레드가 세마포어를 해제가능

**뮤텍스**

: 공유된 자원의 데이터를 여러 프로세스, 스레드가 접근하는 것을 막음.

세마포어랑 비슷한데 갯수가 1개 & key가 존재.

: 일종의 Locking메커니즘 공유된 자원에 대한 접근을 조율하기 위해서 locking과 unlocking을 사용. lock에 대한 소유권이 있으며, lock을 가지고 있을 경우에만 공유 자원에 접근이 가능하고 lock을 가진 사람만 반납이 가능하다.

**모니터**

: 뮤텍스와 환경변수를 가지고 있는 동기화 매커니즘(?)

=> 뮤텍스와 세마포어 모두 완벽하지 않음. 기법을 사용하더라도 데이터 무결성을 보장할 수 없고 데드락이 발생할 수도 있다.


# 인터럽트

**인터럽트** : 프로그램을 실행하는 도중 예기치 않은 상황이 발생할 경우 현재 실행중인 작업을 즉시 중단하고 발생된 상황을 우선 처리하도록 하는 것

**종류**
- 외부 인터럽트 : 입,출력장치, 타이밍 장치, 전원 등 외부적 요인으로 발생
	- 전원이상


